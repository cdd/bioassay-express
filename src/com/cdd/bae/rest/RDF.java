/*
	BioAssay Express (BAE)

	Copyright 2016-2023 Collaborative Drug Discovery, Inc.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

package com.cdd.bae.rest;

import com.cdd.bae.config.*;
import com.cdd.bae.config.authentication.Authentication.*;
import com.cdd.bae.data.*;
import com.cdd.bae.util.*;
import com.cdd.bao.template.*;
import com.cdd.bao.util.*;

import static com.cdd.bao.template.ModelSchema.*;
import static com.cdd.bae.util.ProtoRDF.*;

import java.io.*;
import java.net.*;
import java.time.format.*;
import java.util.*;

import javax.servlet.http.*;

import org.apache.jena.rdf.model.*;
import org.json.*;

/*
	RDF: provides access to semantically-formatted snippets that represents the useful data stored within the BAE
	database. Can be viewed in human readable form, or native semantic (RDF/TTL).
*/

public class RDF extends RESTBaseServlet 
{
	private static final List<ContentType> downloadFormats = Arrays.asList(ContentType.JSONLD, ContentType.TTL, ContentType.RDF);
	private static final String ANNOTATING = "#annotating";
	private static final String ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID = "annotating of assay with unique ID ";
	private static final String ASSAY = "/assay-";
	private static final String ASSAY_AID = "/assay-aid";
	private static final String ASSAY_WITH_UNIQUE_ID = "assay with unique ID ";
	private static final String CURATED = "/curated";
	private static final String REFERENCE_TO_ORIGINAL_DATA = "Reference to original data";
	private static final String SCHEMA = "/schema-";
	private static final String SCHEMABRANCH = "/schemabranch-";
	private static final String TEMPLATES = "/templates";
	private static final String UNCURATED = "/uncurated";
	private static final String PROVISIONAL = "/provisional";
	private static final String UNKNOWN_NAME = "unknown name";
	private static final String WAS_INVALIDATED_BY = "was invalidated by";
	private static final String WAS_INVALIDATED_BY_URI = "wasInvalidatedBy";
	private static final String WAS_GENERATED_BY = "was generated by";
	private static final String WAS_GENERATED_BY_URI = "wasGeneratedBy";
	private static final String WAS_REVISION_OF = "was revision of";
	private static final String WAS_REVISION_OF_URI = "wasRevisionOf";

	private static final long serialVersionUID = 1L;
	
	// ------------ public methods ------------

	@Override
	protected JSONObject processRequest(JSONObject input, Session session) throws RESTException
	{
		// not required here, we override the process method
		return null;
	}

	@Override
	protected void process(HttpServletRequest request, HttpServletResponse response, boolean isPost) throws IOException
	{
		try
		{
			LoginSupport login = new LoginSupport(request);

			int version = Util.safeInt(request.getParameter("version"), 0);

			String pfx = request.getContextPath() + request.getServletPath();
			String url = request.getRequestURL().toString();
			String path = new URL(url).getPath(), ref = new URL(url).getRef();

			// guess the output type by extension; default is HTML
			ContentType contentType = ContentType.fromPath(path);
			
			// remove the suffix from end of path
			int snip = path.lastIndexOf('.');
			if (contentType == ContentType.UNKNOWN) snip = -1;
			if (snip >= 0) path = path.substring(0, snip);

			// change unknown to HTML and JSON to JSONLD
			if (contentType == ContentType.UNKNOWN) contentType = ContentType.HTML;
			else if (contentType == ContentType.JSON) contentType = ContentType.JSONLD;

			Map<String, String> rdfPrefixes = ModelSchema.getPrefixes();

			String baseURI;
			if (Common.getConfiguration().getParams().baseURL == null)
			{
				logger.info("Possiblity of Redirect/Phishing via HTTP Host Injection (CDD-01-003 Web)");
				baseURI = new URL(new URL(url), path + "/..").toString();
				if (baseURI.endsWith("/")) baseURI = baseURI.substring(0, baseURI.length() - 1);
			}
			else
			{
				baseURI = Common.getConfiguration().getParams().baseURL.replaceAll("/+$", "") + request.getServletPath();
			}

			if (!path.startsWith(pfx)) throw new IOException("Incoming URL path [" + path + "] does not match prefix [" + pfx + "]");
			String cmd = path.substring(pfx.length());
			if (ref != null) cmd += ref;
			
			String result = execute(baseURI, login, rdfPrefixes, cmd, contentType, version);
			String filename = null;
			if (downloadFormats.contains(contentType))
				filename = new File(new URL(url).getFile()).getName();
			
			prepareResponse(response, result, contentType, filename);
		}
		catch (Exception ex)
		{
			if (!(ex instanceof IOException)) ex = new IOException(ex);
			logger.error("URL causing exception : {}", request.getRequestURL());
			logger.error("Query string : {}", request.getQueryString());
			throw (IOException)ex;
		}
	}
	
	public String execute(String baseURI, LoginSupport login, Map<String, String> rdfPrefixes, String cmd, ContentType fmt) throws IOException
	{
		return execute(baseURI, login, rdfPrefixes, cmd, fmt, 0);
	}
	public String execute(String baseURI, LoginSupport login, Map<String, String> rdfPrefixes, String cmd, ContentType fmt, int version) throws IOException		
	{
		Node root;
		boolean isEntrypoint = false;
		if (cmd.equals("/all")) {root = buildEntrypoint(baseURI); isEntrypoint = true;}
		else if (cmd.equals(TEMPLATES)) root = buildTemplates(baseURI);
		else if (cmd.equals(CURATED)) root = buildCurated(baseURI);
		else if (cmd.equals(UNCURATED)) root = buildUncurated(baseURI);
		else if (cmd.startsWith(SCHEMA)) root = buildSchema(baseURI, rdfPrefixes, cmd, cmd.substring(SCHEMA.length()), false);
		else if (cmd.startsWith(SCHEMABRANCH)) root = buildSchema(baseURI, rdfPrefixes, cmd, cmd.substring(SCHEMABRANCH.length()), true);
		else if (cmd.startsWith(ASSAY_AID)) root = buildAssay(baseURI, "pubchemAID:" + cmd.substring(ASSAY_AID.length()), version); // legacy
		else if (cmd.startsWith(ASSAY)) root = buildAssay(baseURI, URLDecoder.decode(cmd.substring(ASSAY.length()), Util.UTF8), version);
		else if (cmd.startsWith(PROVISIONAL)) root = buildProvisional(baseURI, version);
		else throw new IOException("Unexpected command path: [" + cmd + "].");
	
		boolean includeDownload = isEntrypoint && login.isLoggedIn();
		return new ProtoRDF(baseURI, rdfPrefixes, fmt, version, includeDownload).render(root);
	}
	
	// fills out just one assay, and returns its constructed URI
	public static String populateAssay(String baseURI, DataObject.Assay assay, Model model) throws IOException
	{
		Node root = new RDF().buildAssay(baseURI, assay, 0);
		ProtoRDF.renderModel(root, model);
		return root.valueURI;
	}
	
	// ------------ private methods ------------
		
	private String renderHTMLerror(String baseURI, String message)
	{
		StringBuilder html = new StringBuilder();
		
		html.append("<html>\n<head>\n");
		html.append("<title>Semantic Web/REST</title>\n");
		html.append("<style>td {vertical-align: top;}</style>\n");
		html.append("</head>\n<body>\n");
		
		html.append("<h1>Export error (Semantic Web/REST)</h1>\n");
		html.append("<p>" + message + "</p>\n");
		html.append("<p><a href='" + baseURI + "/all'>Back to 'Semantic Web/REST'</a></p>");
		html.append("</body>\n</html>\n");
		
		return html.toString();
	}
	
	// if possible add a link, otherwise add the underlined label
	private static void appendNodeLink(String baseURI, StringBuilder html, String uri, String label)
	{
		if (uri == null)
			html.append(label != null ? label : uri);
		else
		{
			boolean isLink = uri.startsWith(baseURI);
			html.append("<nobr>");
			if (isLink)
				appendLink(html, uri, label);
			else
				html.append("<b>" + (label != null ? label : uri) + "</b>");
			html.append("</nobr>\n");
		}
	}
	
	// append a HTML to the string buffer
	private static void appendLink(StringBuilder html, String uri, String label)
	{
		html.append("<a href=\"" + uri + "\">");
		html.append(label != null ? label : uri);
		html.append("</a> ");
	}
	
	// creates a node hierarchy that introduces everything that the RDF system has to offer
	private Node buildEntrypoint(String baseURI)
	{
		Node root = Node.root(baseURI + "/all", "BioAssayExpress RDF");
		
		String propTemplates = PFX_BAT + "hasTemplates";
		String propCurated = PFX_BAT + "hasCurated";
		String propUncurated = PFX_BAT + "hasUncurated";
		String propProvisional = PFX_BAT + "hasProvisional";
		
		root.append(Node.property(propTemplates, "has schema templates", baseURI + TEMPLATES, "schema templates"));
		root.append(Node.property(propCurated, "has curated assays", baseURI + CURATED, "curated assays"));
		root.append(Node.property(propUncurated, "has uncurated assays", baseURI + UNCURATED, "uncurated assays"));
		root.append(Node.property(propProvisional, "has provisional terms", baseURI + PROVISIONAL, "provisional terms"));
		
		return root;
	}
	
	// make a list of schema templates that are available
	private Node buildTemplates(String baseURI)
	{
		Node root = Node.root(baseURI + TEMPLATES, "schema templates");
		
		String propTemplate = PFX_BAT + "hasTemplate";

		for (int n = 0; n < Common.getAllSchemata().length; n++)
		{
			// NOTE: would be better to have a unique ID per template, but for now, index will suffice
			String uri = baseURI + SCHEMA + n;
			root.append(Node.property(propTemplate, "has template", uri, "template schema #" + n));
		}
		for (int n = 0; n < Common.getBranchSchemata().length; n++)
		{
			String uri = baseURI + SCHEMABRANCH + n;
			root.append(Node.property(propTemplate, "has template", uri, "template schema branch #" + n));
		}
		
		return root;
	}
	
	// make a list of curated assays
	private Node buildCurated(String baseURI) throws IOException
	{
		Node root = Node.root(baseURI + CURATED, "curated assays");
		
		String propAssay = PFX_BAT + "hasAssay";
		
		for (String uid : Common.getDataStore().assay().fetchAllCuratedUniqueID())
		{
			String uri = baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8);
			root.append(Node.property(propAssay, "has assay", uri, ASSAY_WITH_UNIQUE_ID + uid));
		}
		return root;
	}
	
	// make a list of uncurated assays
	private Node buildUncurated(String baseURI) throws IOException
	{
		Node root = Node.root(baseURI + UNCURATED, "uncurated assays");
		
		String propAssay = PFX_BAT + "hasAssay";

		for (String uniqueID : Common.getDataStore().assay().fetchAllNonCuratedUniqueID())
		{
			// ignore assays that are not from pubchem
			Identifier.UID uid = Common.getIdentifier().parseKey(uniqueID);
			if (uid == null || !uid.source.prefix.equals(Identifier.PUBCHEM_PREFIX)) continue;
			
			String uri = baseURI + ASSAY + URLEncoder.encode(uniqueID, Util.UTF8);
			root.append(Node.property(propAssay, "has assay", uri, "assay with PubChem AID " + uniqueID));
		}
		return root;
	}
	
	// serialise an individual schema
	private Node buildSchema(String baseURI, Map<String, String> rdfPrefixes, String cmd, String section, boolean isBranch) throws IOException
	{
		int dash = section.indexOf('-');
		int idx = Integer.valueOf(dash < 0 ? section : section.substring(0, dash));
	
		Schema schema = null;
		Node root = null;
		
		if (!isBranch)
		{
			schema = Common.getAllSchemata()[idx];
			root = Node.root(baseURI + SCHEMA + idx, "template schema #" + idx);
		}
		else
		{
			schema = Common.getBranchSchemata()[idx];
			root = Node.root(baseURI + SCHEMABRANCH + idx, "branch schema #" + idx);
		}
		
		// if this is a request for the tree content, build that now
		if (dash >= 0)
		{
			return buildTree(baseURI, rdfPrefixes, cmd, schema, section.substring(dash + 1));
		}
		
		// perform the basic serialisation, which is done by the ModelSchema class
		Model model = ModelFactory.createDefaultModel();
		ModelSchema thing = new ModelSchema(schema, model);
		thing.exportToModel();
		String modelURI = thing.getRootURI();
		
		Property propTree = model.createProperty(PFX_BAT + "hasTree");
		for (Schema.Assignment assn : schema.getRoot().flattenedAssignments())
		{
			Resource subject = model.createResource(thing.getURIForAssignment(assn));
			String locator = schema.locatorID(assn);
			Resource object = model.createResource(ProtoRDF.normaliseURI(baseURI + cmd + "-" + locator));
			model.add(subject, propTree, object);
		}
		
		root.append(Node.model(PFX_BAT + "defSchema", "schema definition", modelURI, model));
		
		rdfPrefixes.put("bas", schema.getSchemaPrefix());

		return root;
	}
	
	// serialise the tree that comes along with an assignment within a schema
	private Node buildTree(String baseURI, Map<String, String> rdfPrefixes, String cmd, Schema schema, String locator)
	{
		Schema.Assignment assn = schema.obtainAssignment(locator);
		SchemaTree tree = Common.obtainTree(schema, assn);
		
		Node root = Node.root(baseURI + cmd, "schema tree for [" + assn.name + "]");
		
		SchemaTree.Node[] list = tree.getFlat();
		Node[] local = new Node[list.length];
		for (int n = 0; n < list.length; n++)
		{
			local[n] = Node.property(PFX_BAT + "hasChild", "has child", list[n].uri, list[n].label);
			if (Util.notBlank(list[n].descr)) local[n].append(Node.literal(PFX_BAT + "hasDescr", "has description", list[n].descr));
			if (list[n].altLabels != null) 
				for (String label : list[n].altLabels) local[n].append(Node.literal(PFX_BAT + "hasAltLabel", "has alternate label", label));
			if (list[n].externalURLs != null) 
				for (String url : list[n].externalURLs) local[n].append(Node.literal(PFX_BAT + "hasExternURL", "has external URL", url));
		
			int parent = list[n].parentIndex;
			if (parent < 0) root.append(local[n]); else local[parent].append(local[n]);
		}
		
		return root;
	}
	
	// serialise an individual assay
	private Node buildAssay(String baseURI, String uid, int version) throws IOException
	{
		DataStore store = Common.getDataStore();
		DataObject.Assay assay = store .assay().getAssayFromUniqueID(uid);
		if (assay == null) throw new IOException("Assay " + uid + " not found");
		return buildAssay(baseURI, assay, version);
	}
	private Node buildAssay(String baseURI, DataObject.Assay assay, int version) throws IOException
	{
		DataStore store = Common.getDataStore();
		
		String uid = assay.uniqueID;
		if (Util.isBlank(uid)) uid = "assayID_" + assay.assayID; // better than nothing, and can't be null

		if (assay.history == null) assay.history = new DataObject.History[]{};
		version = assay.history.length >= version && version > 0 ? version : assay.history.length;
		
		Node root = Node.root(baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + version, ASSAY_WITH_UNIQUE_ID + uid + ", version " + version);
		
		final String originalURL = Common.getIdentifier().composeRefURL(uid);
		
		Schema schema = Common.getSchema(assay.schemaURI);
		String schemaName = schema == null ? "schema URI" : schema.getRoot().name;
		
		if (assay.text != null) root.append(Node.property(PFX_BAT + "hasText", "has assay text", null, assay.text));
		root.append(Node.property(PFX_BAT + "schemaURI", "has schema", assay.schemaURI, schemaName));
		root.append(Node.property(PFX_BAT + "refOriginal", "reference to original", originalURL, REFERENCE_TO_ORIGINAL_DATA));
		root.append(Node.property(PFX_PROV + "wasDerivedFrom", "was derived from", originalURL, REFERENCE_TO_ORIGINAL_DATA));
		root.append(Node.literal(PFX_BAT + "isCurated", "is curated", String.valueOf(assay.isCurated)));
		
		if (assay.isCurated)
		{
			String curator = assay.history[version - 1].curatorID;
			DataObject.User user = store.user().getUser(curator);
			Node rootAnnotatingActivity = root.append(Node.property(PFX_PROV + WAS_GENERATED_BY_URI, WAS_GENERATED_BY, 
				baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + version + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + version));
			
			root.append(Node.literal(PFX_PROV + "wasAttributedTo", "was attributed to", user != null ? user.name : UNKNOWN_NAME));
			root.append(Node.literal(PFX_PROV + "generatedAtTime", "generated at", DateTimeFormatter.ISO_INSTANT.format(assay.history[version - 1].curationTime.toInstant())));
			
			rootAnnotatingActivity.append(Node.property(PFX_PROV + "used", "used", originalURL, REFERENCE_TO_ORIGINAL_DATA));
			rootAnnotatingActivity.append(Node.literal(PFX_PROV + "wasAssociatedWith", "was associated with", user != null ? user.name : UNKNOWN_NAME));
			rootAnnotatingActivity.append(Node.literal(PFX_PROV + "endAtTime", "was finished at", DateTimeFormatter.ISO_INSTANT.format(assay.history[version - 1].curationTime.toInstant())));
			
			Node lastAssay = root;
			for (int i = version - 1; i > 0; i--)
			{
				lastAssay = lastAssay.append(Node.property(PFX_PROV + WAS_REVISION_OF_URI, WAS_REVISION_OF, 
					baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + i, ASSAY_WITH_UNIQUE_ID + uid + ", version " + i));
				lastAssay.append(Node.property(PFX_PROV + WAS_GENERATED_BY_URI, WAS_GENERATED_BY, 
					baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + i + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + i));
				lastAssay.append(Node.property(PFX_PROV + WAS_INVALIDATED_BY_URI, WAS_INVALIDATED_BY, 
					baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + (i + 1) + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + (i + 1)));
			}
			if (assay.history.length > version) 
			{
				lastAssay = Node.root(baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + assay.history.length, ASSAY_WITH_UNIQUE_ID + uid + ", version " + assay.history.length);
				lastAssay.append(Node.property(PFX_PROV + WAS_GENERATED_BY_URI, WAS_GENERATED_BY, 
					baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + assay.history.length + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + assay.history.length));
					
				for (int i = assay.history.length - 1; i > version; i--)
				{
					lastAssay = lastAssay.append(Node.property(PFX_PROV + WAS_REVISION_OF_URI, WAS_REVISION_OF, 
						baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + i, ASSAY_WITH_UNIQUE_ID + uid + ", version " + i));
					lastAssay.append(Node.property(PFX_PROV + WAS_GENERATED_BY_URI, WAS_GENERATED_BY, 
						baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + i + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + i));
					lastAssay.append(Node.property(PFX_PROV + WAS_INVALIDATED_BY_URI, WAS_INVALIDATED_BY, 
						baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + (i + 1) + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + (i + 1)));
				}
				
				root.append(Node.property(PFX_PROV + WAS_INVALIDATED_BY_URI, WAS_INVALIDATED_BY, baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + (version + 1) + ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + (version + 1)));
				lastAssay.append(Node.property(PFX_PROV + WAS_REVISION_OF_URI, WAS_REVISION_OF, root));
			}
		}
		
		List<DataObject.Annotation> annotations = new ArrayList<>(Arrays.asList(assay.annotations != null ? assay.annotations : new DataObject.Annotation[] {}));
		if (assay.history != null) for (int i = assay.history.length - 1; i > version - 1; i--)
		{
			if (assay.history[i].annotsAdded != null) annotations.removeAll(Arrays.asList(assay.history[i].annotsAdded));
			if (assay.history[i].annotsRemoved != null) annotations.addAll(Arrays.asList(assay.history[i].annotsRemoved));
		}

		for (DataObject.Annotation annot : annotations)
		{
			Node blank = root.append(Node.placeholder(PFX_BAT + "hasAnnotation", "has annotation"));
			blank.append(Node.property(PFX_BAT + "hasProperty", "has property", annot.propURI, Common.getOntoProps().getLabel(annot.propURI)));
			if (annot.groupNest != null && annot.groupNest.length > 0)
			{
				String[] groupLabel = new String[annot.groupNest.length];
				for (int n = 0; n < groupLabel.length; n++) groupLabel[n] = Common.getOntoProps().getLabel(annot.groupNest[n]);
				blank.append(Node.valueList(PFX_BAT + "hasGroup", "has group", annot.groupNest, groupLabel));
			}

			String valueLabel = Common.getCustomName(schema, annot.propURI, annot.groupNest, annot.valueURI);
			if (valueLabel == null) valueLabel = Common.getOntoValues().getLabel(annot.valueURI);

			blank.append(Node.property(PFX_BAT + "hasValue", "has value", annot.valueURI, valueLabel));
			if (assay.isCurated)
			{
				String curator = null;
				Date curationTime = null;
				int generatedAtVersion = 0, removedAtVersion = 0;
				for (int i = 0; i < version; i++)
				{
					DataObject.History history = assay.history[i];
					if (history.annotsAdded != null) for (DataObject.Annotation origin : history.annotsAdded)
					{
						if (origin.propURI.equals(annot.propURI) && origin.valueURI.equals(annot.valueURI))
						{
							curator = history.curatorID;
							curationTime = history.curationTime;
							generatedAtVersion = i + 1;
						}
					}
				}
				for (int i = version; i < assay.history.length; i++)
				{
					DataObject.History history = assay.history[i];
					if (history.annotsRemoved != null) for (DataObject.Annotation origin : history.annotsRemoved)
					{
						if (origin.propURI.equals(annot.propURI) && origin.valueURI.equals(annot.valueURI))
						{
							removedAtVersion = i + 1;
							break;
						}
					}
				}
				if (curator != null)
				{
					DataObject.User user = store.user().getUser(curator);
					blank.append(Node.literal(PFX_PROV + "wasAttributedTo", "was attributed to", user != null ? user.name : UNKNOWN_NAME));
				}
				if (curationTime != null)
				{
					blank.append(Node.literal(PFX_PROV + "generatedAtTime", "generated at", DateTimeFormatter.ISO_INSTANT.format(curationTime.toInstant())));
				}
				if (generatedAtVersion > 0)
				{
					blank.append(Node.property(PFX_PROV + WAS_GENERATED_BY_URI, WAS_GENERATED_BY, 
						baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + generatedAtVersion + 
						ANNOTATING, ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + generatedAtVersion));
				}
				if (removedAtVersion > 0)
				{
					blank.append(Node.property(PFX_PROV + WAS_INVALIDATED_BY_URI, WAS_INVALIDATED_BY, 
						baseURI + ASSAY + URLEncoder.encode(uid, Util.UTF8) + "?version=" + removedAtVersion + ANNOTATING, 
						ANNOTATING_OF_ASSAY_WITH_UNIQUE_ID + uid + ", version " + removedAtVersion));
				}
			}
		}
		if (assay.textLabels != null) for (DataObject.TextLabel label : assay.textLabels)
		{
			Node blank = root.append(Node.placeholder(PFX_BAT + "hasAnnotation", "has annotation"));
			blank.append(Node.property(PFX_BAT + "hasProperty", "has property", label.propURI, Common.getOntoProps().getLabel(label.propURI)));
			blank.append(Node.property(PFX_BAT + "hasValue", "has value", null, label.text));
		}
		
		return root;
	}
	
	private Node buildProvisional(String baseURI, int version) throws IOException
	{
		Node root = Node.root(baseURI + PROVISIONAL + "?version=" + version, "provisional terms");
	
		DataObject.Provisional[] terms = Common.getDataStore().provisional().fetchAllTerms();
	
		for (DataObject.Provisional term : terms)
		{
			Node node = Node.property(PFX_BAT + "hasProvisional", "provisional", term.uri, null);
			root.append(node);
			
			node.append(Node.property(PFX_RDFS + "subClassOf", "subclass", term.parentURI, null));
			if (term.label != null) node.append(Node.literal(PFX_RDFS + "label", "label", term.label));
			if (term.description != null) node.append(Node.literal(PFX_OBO + "IAO_0000115", "descr", term.description));
			
			// other ontolobridge details
			node.append(Node.literal(PFX_BAT + "hasProvisionalID", "provisionalID", String.valueOf(term.provisionalID)));
			if (term.explanation != null) node.append(Node.literal(PFX_BAT + "hasExplanation", "explanation", term.explanation));
			if (term.remappedTo != null) node.append(Node.property(PFX_BAT + "isRemappedTo", "remappedTo", term.remappedTo, null));
			if (term.bridgeStatus != null) node.append(Node.literal(PFX_BAT + "hasBridgeStatus", "bridgeStatus", term.bridgeStatus));
			if (term.bridgeURL != null) node.append(Node.literal(PFX_BAT + "hasBridgeURL", "bridgeURL", term.bridgeURL));
			if (term.bridgeToken != null) node.append(Node.literal(PFX_BAT + "hasBridgeToken", "bridgeToken", term.bridgeToken));
		}
		
		return root;
	}
}
