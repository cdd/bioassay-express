/*
	BioAssay Express (BAE)

	Copyright 2016-2023 Collaborative Drug Discovery, Inc.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

namespace BioAssayExpress /* BOF */ {

/*
	Merging assays: starts with an assay and grafts in content from another source, such as a JSON object
	holding assay information according to the same data layout. The canonical use scenario is for pasting or
	dragging objects into the assignment page.

	The assay parameter will be modified directly if any changes were successfully made.
*/

export class MergeAssay
{
	public changedText = false; // set if the modification changed the main protocol text
	public changedUniqueID = false; // set if the uniqueID changed
	public changedSchema = false; // set if the schema or its branch/duplication is different
	public changedAnnotations = false; // set if the annotation list has been modified

	// ------------ public methods ------------

	constructor(public assay:AssayDefinition, private availableTemplates:TemplateSummary[])
	{
	}

	// incorporates content from an incoming assay description; the object typically follows the AssayDefinition
	// format (and will usually have been generated by serialisation of those); returns false if no changes were
	// made (which is not distinguished from an error condition)
	public apply(obj:any):boolean
	{
		let modified = false;

		if (obj.text && obj.text != this.assay.text)
		{
			this.assay.text = obj.text;
			this.changedText = true;
			modified = true;
		}
		if (obj.uniqueID && obj.uniqueID != this.assay.uniqueID)
		{
			this.assay.uniqueID = obj.uniqueID;
			this.changedUniqueID = true;
			modified = true;
		}
		if (obj.schemaURI && this.applySchema(obj.schemaURI, obj.schemaBranches, obj.schemaDuplication))
		{
			this.changedSchema = true;
			modified = true;
		}
		if (obj.annotations && this.applyAnnotations(obj.annotations))
		{
			this.changedAnnotations = true;
			modified = true;
		}

		return modified;
	}

	// ------------ private methods ------------

	// given that a schema is available, and branch/duplication maybe, applies the changes
	private applySchema(schemaURI:string, schemaBranches:SchemaBranch[], schemaDuplication:SchemaDuplication[]):boolean
	{
		let modified = schemaURI != this.assay.schemaURI;
		this.assay.schemaURI = schemaURI;

		if (!this.assay.schemaBranches) this.assay.schemaBranches = [];
		if (!this.assay.schemaDuplication) this.assay.schemaDuplication = [];

		// duplicate indicators sometimes have to be merged: take the maximum
		let duplication = schemaDuplication ? schemaDuplication.slice(0) : [];
		for (let n = 0; n < duplication.length; n++)
		{
			for (let i = 0; i < this.assay.schemaDuplication.length; i++)
			{
				let current = this.assay.schemaDuplication[i];
				if (!Vec.equals(duplication[n].groupNest, current.groupNest)) continue;
				if (duplication[n].multiplicity > current.multiplicity)
				{
					current.multiplicity = duplication[n].multiplicity;
					modified = true;
				}
				duplication.splice(n, 1);
				n--;
				break;
			}
		}
		this.assay.schemaDuplication = Vec.concat(this.assay.schemaDuplication, duplication);
		if (duplication.length > 0) modified = true;

		// schema branches: just need to make sure they're not duplicates
		if (schemaBranches) for (let n = 0; n < schemaBranches.length; n++)
		{
			let branch = schemaBranches[n], got = false;
			for (let i = 0; i < this.assay.schemaBranches.length; i++)
			{
				let look = this.assay.schemaBranches[i];
				if (samePropGroupNest(branch.schemaURI, branch.groupNest, look.schemaURI, look.groupNest)) {got = true; break;}
			}
			if (!got) this.assay.schemaBranches.push(branch);
			modified = true;
		}

		return modified;
	}

	// takes the given annotations and adds them without duplications
	private applyAnnotations(annotations:AssayAnnotation[]):boolean
	{
		let makeKey = (annot:AssayAnnotation):string =>
			keyPropGroupValue(annot.propURI, annot.groupNest, annot.valueURI ? annot.valueURI : '"' + annot.valueLabel + '"');

		let current = new Set<string>();
		for (let annot of this.assay.annotations) current.add(makeKey(annot));

		let modified = false;

		for (let annot of annotations)
		{
			let key = makeKey(annot);
			if (current.has(key)) continue;
			current.add(key);
			this.assay.annotations.push(annot);
			modified = true;
		}
		this.assay.annotations = PageAssignment.cleanupAnnotations(this.assay.annotations);

		return modified;
	}
}

/* EOF */ }
